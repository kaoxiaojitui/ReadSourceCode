```
**JVM HotSpot**
```
```
字节码文件 -> 类加载器 -> 内存空间 -> 执行引擎

**类的加载过程**：
类加载 -> （JVM按需加载） 将物理的class文件以二进制字节流的形式加载到内存中方法区
类加载器只负责class文件加载,将类信息，常量等加载到内存的方法区。

链接 -> (验证（cafebabe），准备（为类变量分配内存，初始化零值，final修饰的变量可视为常量，在编译时已赋值），解析（常量池的引用转为直接引用）)

初始化 ->
会从零值重新覆盖static修饰的值
子类的初始化晚于父类
```

```
方法区和堆：在内存当中，多个线程共享
方法区：类的信息，常量，方法信息等
堆区：存放类对象
```
```
生命周期：java程序执行结束时即停止
```

```
双亲委派机制：
递归找到父类加载器，若父类加载器可以完成加载任务则成功返回，否则子类加载器才会去尝试加载

引导类加载器
     ↓
扩展类加载器（ext）
     ↓
系统类加载器（app）
     ↓
自定义类加载器

向下扩展，向上委托

避免类的重复加载；
避免核心api被随意修改（eg.java.lang）（沙箱安全机制）
```

```
**运行时数据区**
每一个线程都含有PC寄存器，执行引擎和虚拟机栈（java栈），线程共享方法区，堆区

程序计数器（PC寄存器）
指向java栈，执行引擎按照指向的指令执行

虚拟机栈（java栈）
大小可以是动态or固定
-Xss 指定栈的内存大小
栈帧为基本存储单位，内部保存了局部变量表，操作数栈，动态链接，方法返回地址等附加信息
方法与栈帧一一对应

局部变量表：定义数字数组来保存方法的参数及局部变量，容量在编译时即确定，在运行时不会改变。
基础存储单元 slot（变量槽），可重复利用

操作数栈：push/pop操作

动态链接：指向运行时常量池的动态引用
```
## JVM的不同区域情况
```
                ERROR                   GC
程序计数器      ×                       ×  
虚拟机栈        √                       ×
本地方法栈      √                       ×
堆              √                       √ minor，major，full
方法区          √                       √ full 
```

## 分带收集
```
Full GC针对的是整个堆空间和方法区的垃圾收集
1，调用System.gc()
2,老年代空间不足
3，方法区空间不足（回收不需要的类和类的加载器）
4，通过Minor GC进入老年代的平均大小大于老年代可用内存
5，由伊甸区，幸存者from区向幸存者to区复制时，对象大小大于to区可用大小，则将对象转存老年代（内存空间足够）
新生代：伊甸园区满时触发Minor GC，会将伊甸园区和幸存者区一起回收
        且当幸存者区同年龄对象总大小大于幸存者区总和一半时，不需要等待到15次minor GC，直接会晋升到老年代
    伊甸园区    可达性分析，引用计数
    幸存者区(0,1)  复制算法   
老年代：在新生代年龄为15时，则将对象从幸存者区晋升到老年代         
老年代空间不足时会尝试先触发Minor GC，若还不足则会出发Major GC，若还不足则OOM
只有在CMS GC才有单独收集老年代的行为
标记清除压缩
元空间：

堆空间：
-Xms：起始内存空间大小，默认是物理内存/64
-Xmx：最大内存空间大小，默认是物理内存/4
-NewRatio:设置新生代与老年代空间大小比例，默认2，即1：2
-SurvivalRatio：设置伊甸区与幸存区空间大小比例，默认8，即8：1：1
    实际还有一个自适应机制，大概是6：1：1的情况，显示手动设置8时才真正为8：1：1
```

## JVM命令
```
jps 查看java进程
    jps 查看java进程号
jstat 查看jvm状态
    jstat -gc [jps获取到的进程号]
    或者 + -XX:PrintGCDetails
jinfo 查看参数状态
    jinfo -flag SurvivorRatio
```

## TLAB
```
JVM为每个线程分配私有的缓存区，包含在Eden区
每个线程会优先在TLAB中创建初始化对象
```

## JVM常用参数
```
-XX:PrintGC 打印GC简要信息
-XX:PrintGCDetails 打印GC detail信息
-Xms 初始堆空间内存（默认是物理内存的1/64）
-Xmx 最大堆空间内存（默认是物理内存的1/4）
-Xmn 新生代空间内存（默认是物理内存的1/64）
-XX:NewRatio  新生代与老年代占比
-XX:SurvivorRatio  Eden与Survivor占比
```

## 逃逸分析 栈
```
方法内的对象不会在方法外被调用(方法执行后，对象就不再被引用了)
public static StringBuffer createStringBuffer(String s1, String s2){
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    //发生逃逸
    //方法内创建的对象return后，可能会被其他对象引用
    return sb;
}
public static String createStringBuffer(String s1, String s2){
    StringBuffer sb = new StringBuffer();
    sb.append(s1);
    sb.append(s2);
    //未发生逃逸
    //方法内创建的对象通过同toString方法会创建一个新的String对象
    //原来的StringBuffer对象不再被其他对象引用
    return sb.toString();
}
```
### 栈上分配
```
未发生逃逸的对象会随着栈帧弹出被抛弃，则不会继续维护在堆中。
```
### 同步省略 -- 锁消除
```
JIT编译期间会把没必要的锁自动去掉，减少同步操作
```
### 分离对象or标量替换
```
标量指无法继续分解成更小数据的数据，如java的基本数据类型。
例如将类对象创建转换成基本数据类型赋值。
```

## 方法区/元空间
```
存放类和类的加载器
full GC时回收
```

## 垃圾回收
### 标记阶段 -- GC Roots 可达性分析
```
可用作GC root的元素：
    虚拟机栈中引用的对象
    本地方法栈内JNI引用的对象
    方法区中类静态属性引用的对象
    方法区中常量引用的对象
    所有被同步锁syncchronized持有的对象
    虚拟机内部的引用
```
### 清除阶段
#### 标记-清除算法
```
标记阶段
标记可达对象，在对象的header中记录
清除header中没有可达标记的对象
```
#### 复制算法
```
新生代幸存者区，交替复制活着的对象
```
#### 标记压缩算法
```
标记清除后，会整理内存空间
```